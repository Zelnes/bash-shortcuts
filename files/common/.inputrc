# Afficher les raccourcis courament présent : bind -P
# From https://linuxfr.org/users/perdu/journaux/faire-de-la-magie-avec-son-inputrc
# "\e"  Désigne la touche "Alt" (au moins celle de gauche, pas encore vu à droite)
# "\e[" Désigne la touche "Ctrl"
# "\C" Désigne aussi la combinaison "Ctrl"

"\e[1;5C": forward-word
"\e[1;5D": backward-word

"\e[5~": history-search-backward
"\e[6~": history-search-forward

# Supprimer le premier mot de la ligne et placer le curseur en début de ligne
"\ej": "\C-a\eD"

# # Remplacer le premier mot de la ligne par "ls" puis placer le curseur en fin de ligne
# "\el": "\ejls\C-e"

# Remplacer le premier mot de la ligne par "cd" puis placer le curseur en fin de ligne
"\ec": "\ejcd\C-e"

# Remplacer le premier mot de la ligne par "subl" puis placer le curseur en fin de ligne
"\es": "\ej${EDITOR}\C-e"

# Ajouter set -x et set +x à la ligne
"\ex": "\C-aset -x; \C-e; set +x"

# Ajouter >/dev/null à la fin
"\en": "\C-e>/dev/null"

# "\e"
"\ea": "\C-aLANG=C "
"\er": "__reload_history\n"

# Join line history
# Move to end of line - Kill up to beginning - Load next history command
# - Move to beginning - Yank killed - Insert "; "
# Example :
# $ p=toto
# $ echo $p
# toto
# <Go back in history twice, to reach 'p=toto' and press "Alt+j">
# $ p=toto; echo $p
"\ek": "\C-e\C-u\C-y\C-n\C-a\C-y; "

# https://stackoverflow.com/q/59929214/5868851
# "em\ej":"zelnes@stackoverflow.com"

"\ef":"\C-afor i in $(\C-e); do \e ; done\C-x\C-x"

# Debuging
#"\eb":print-last-kbd-macro
#"\C-@":set-mark
#"\C-x\C-x":exchange-point-and-mark

set history-size -1

# Pour mettre entre {} les résultats d'une complétion
# complete-into-braces (M-{)

# Après avoir fait plusieurs kill-word, les mots sont stockés
# Pour utiliser les mots, les 'yank' puis les appels suivants
# iront chercher les anciens mots stockés
# yank-pop (M-y)

# Pour récupérer le dernier (nth) argument de la commande précédente
# yank-nth-arg (M-C-y)
# yank-last-arg (M-., M-_)
# insert-last-argument (M-., M-_)

#Keyboard Macros
#       start-kbd-macro (C-x ()
#              Begin saving the characters typed into the current keyboard macro.
#       end-kbd-macro (C-x ))
#              Stop  saving the characters typed into the current keyboard macro and store the defini‐
#              tion.
#       call-last-kbd-macro (C-x e)
#              Re-execute the last keyboard macro defined, by making the characters in the  macro  ap‐
#              pear as if typed at the keyboard.
#       print-last-kbd-macro ()
#              Print the last keyboard macro defined in a format suitable for the inputrc file.

#       set-mark (C-@, M-<space>)
#              Set the mark to the point.  If a numeric argument is supplied, the mark is set to  that
#              position.
#       exchange-point-and-mark (C-x C-x)
#              Swap  the  point  with the mark.  The current cursor position is set to the saved posi‐
#              tion, and the old cursor position is saved as the mark.

#       character-search (C-])
#              A character is read and point is moved to the next occurrence  of  that  character.   A
#              negative count searches for previous occurrences.

#       insert-completions (M-*)
#              Insert all completions of the text before point that would have been generated by possible-completions.
#       complete-into-braces (M-{)
#              Perform  filename completion and insert the list of possible completions enclosed within braces so the list is available to the shell (see Brace Ex‐
#              pansion above).

# Disable F***ing bell, for windows...
set bell-style none

"\C-x\C-r": re-read-init-file
